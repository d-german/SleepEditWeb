@using SleepEditWeb.Models
@model ProtocolEditorViewModel
@{
    ViewData["Title"] = "Protocol Editor";
}

@Html.AntiForgeryToken()

<div class="page-header d-flex flex-wrap justify-content-between align-items-center gap-2">
    <div>
        <h1 class="page-title">Protocol Editor</h1>
        <p class="page-subtitle">Build, organize, and export protocol statements.</p>
    </div>
    <div class="d-flex flex-wrap gap-2">
        <button type="button" id="addSectionBtn" class="btn btn-outline-primary">Add Section</button>
        <button type="button" id="addChildBtn" class="btn btn-outline-primary">Add Child</button>
        <button type="button" id="removeNodeBtn" class="btn btn-outline-danger">Remove</button>
        <button type="button" id="undoBtn" class="btn btn-outline-secondary">Undo</button>
        <button type="button" id="redoBtn" class="btn btn-outline-secondary">Redo</button>
        <button type="button" id="resetBtn" class="btn btn-outline-secondary">Reset</button>
        <button type="button" id="toggleAllSectionsBtn" class="btn btn-outline-secondary">Collapse Sections</button>
        <button type="button" id="importXmlBtn" class="btn btn-outline-primary">Import Protocol</button>
        <button type="button" id="saveXmlBtn" class="btn btn-outline-primary">Save Protocol</button>
        <button type="button" id="setDefaultProtocolBtn" class="btn btn-outline-primary">Set As Default</button>
        <button type="button" id="exportXmlBtn" class="btn btn-primary">Export Protocol</button>
    </div>
</div>
<input id="importXmlFileInput" type="file" accept=".xml,text/xml,application/xml" class="d-none" />

<div class="row g-3 protocol-editor-shell">
    <div class="col-12 col-xl-4">
        <div class="dashboard-card h-100">
            <div class="dashboard-card-header">
                <i class="bi bi-diagram-3 me-2"></i>Protocol Tree
            </div>
            <div class="dashboard-card-body">
                <div id="protocolTree" class="protocol-tree-host"></div>
            </div>
        </div>
    </div>
    <div class="col-12 col-xl-8">
        <div class="dashboard-card">
            <div class="dashboard-card-header">
                <i class="bi bi-file-earmark-text me-2"></i>Statement Info
            </div>
            <div class="dashboard-card-body">
                <div class="row g-3">
                    <div class="col-12">
                        <label for="nodeTextInput" class="form-label">Statement Text</label>
                        <textarea id="nodeTextInput" class="form-control" rows="5"></textarea>
                    </div>
                </div>
            </div>
        </div>

        <div class="dashboard-card mt-3">
            <div class="dashboard-card-header">
                <i class="bi bi-list-check me-2"></i>SubText Info
            </div>
            <div class="dashboard-card-body">
                <div class="row g-3">
                    <div class="col-12 col-lg-7">
                        <label for="subTextList" class="form-label">SubText</label>
                        <select id="subTextList" class="form-select" size="5"></select>
                    </div>
                    <div class="col-12 col-lg-5">
                        <label for="subTextInput" class="form-label">New Item</label>
                        <input id="subTextInput" type="text" class="form-control mb-2" />
                        <div class="d-flex gap-2">
                            <button type="button" id="addSubTextBtn" class="btn btn-outline-primary btn-sm">Add Item</button>
                            <button type="button" id="removeSubTextBtn" class="btn btn-outline-danger btn-sm">Remove Item</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="dashboard-card mt-3">
            <div class="dashboard-card-header">
                <i class="bi bi-link-45deg me-2"></i>Link Info
            </div>
            <div class="dashboard-card-body">
                <div class="row g-3">
                    <div class="col-12 col-md-4">
                        <label class="form-label">Statement Id</label>
                        <input id="statementIdInput" type="text" class="form-control" readonly />
                    </div>
                    <div class="col-12 col-md-4">
                        <label for="linkIdInput" class="form-label">Link Id</label>
                        <input id="linkIdInput" type="number" class="form-control" />
                    </div>
                    <div class="col-12 col-md-4">
                        <label for="linkTextInput" class="form-label">Link Text</label>
                        <input id="linkTextInput" type="text" class="form-control" />
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="nodeContextMenu" class="dropdown-menu shadow-sm" style="position: fixed; display: none; z-index: 1080;">
    <button type="button" id="contextMenuSelectLinkBtn" class="dropdown-item">Select Link...</button>
    <button type="button" id="contextMenuClearLinkBtn" class="dropdown-item text-danger">Clear Link</button>
</div>

<div class="modal fade" id="linkPickerModal" tabindex="-1" aria-labelledby="linkPickerModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-scrollable modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="linkPickerModalLabel">Select Link Node</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div id="linkPickerSourceLabel" class="small text-muted mb-2"></div>
                <label for="linkPickerSearchInput" class="form-label">Search</label>
                <input id="linkPickerSearchInput" type="text" class="form-control mb-3 protocol-link-picker-search" placeholder="Filter by node text or id" />
                <div id="linkPickerTree" class="rounded p-2 protocol-link-picker-tree"></div>
            </div>
        </div>
    </div>
</div>

<div id="protocolEditorStatus" class="small text-muted mt-3">Ready</div>

@section Scripts {
<script>
    (function () {
        const token = document.querySelector('input[name="__RequestVerificationToken"]').value;
        const statusEl = document.getElementById('protocolEditorStatus');
        const treeHost = document.getElementById('protocolTree');
        const nodeTextInput = document.getElementById('nodeTextInput');
        const statementIdInput = document.getElementById('statementIdInput');
        const linkIdInput = document.getElementById('linkIdInput');
        const linkTextInput = document.getElementById('linkTextInput');
        const subTextInput = document.getElementById('subTextInput');
        const subTextList = document.getElementById('subTextList');
        const importXmlFileInput = document.getElementById('importXmlFileInput');
        const nodeContextMenu = document.getElementById('nodeContextMenu');
        const contextMenuSelectLinkBtn = document.getElementById('contextMenuSelectLinkBtn');
        const contextMenuClearLinkBtn = document.getElementById('contextMenuClearLinkBtn');
        const linkPickerModalEl = document.getElementById('linkPickerModal');
        const linkPickerSourceLabel = document.getElementById('linkPickerSourceLabel');
        const linkPickerSearchInput = document.getElementById('linkPickerSearchInput');
        const linkPickerTree = document.getElementById('linkPickerTree');
        const toggleAllSectionsBtn = document.getElementById('toggleAllSectionsBtn');

        let state = {
            document: @Html.Raw(Json.Serialize(Model.InitialDocument)),
            undoCount: 0,
            redoCount: 0,
            lastUpdatedUtc: null
        };
        let selectedNodeId = null;
        let dragNodeId = null;
        let contextMenuNodeId = null;
        let linkPickerSourceNodeId = null;
        let linkPickerModal = null;
        let pendingScrollToNodeId = null;
        const collapseStorageKey = 'protocolEditor.collapsedSections';
        const linkPickerCollapseStorageKey = 'protocolEditor.linkPickerCollapsedSections';
        let collapsedSectionIds = loadCollapsedIdSet(collapseStorageKey);
        let collapsedLinkPickerSectionIds = loadCollapsedIdSet(linkPickerCollapseStorageKey);

        document.getElementById('addSectionBtn').addEventListener('click', onAddSection);
        document.getElementById('addChildBtn').addEventListener('click', onAddChild);
        document.getElementById('removeNodeBtn').addEventListener('click', onRemoveNode);
        document.getElementById('undoBtn').addEventListener('click', () => postState('Undo', {}));
        document.getElementById('redoBtn').addEventListener('click', () => postState('Redo', {}));
        document.getElementById('resetBtn').addEventListener('click', onReset);
        toggleAllSectionsBtn.addEventListener('click', onToggleAllSections);
        document.getElementById('importXmlBtn').addEventListener('click', onImportXml);
        importXmlFileInput.addEventListener('change', onImportXmlSelected);
        document.getElementById('saveXmlBtn').addEventListener('click', onSaveXml);
        document.getElementById('setDefaultProtocolBtn').addEventListener('click', onSetDefaultProtocol);
        document.getElementById('exportXmlBtn').addEventListener('click', onExportXml);
        document.getElementById('addSubTextBtn').addEventListener('click', onAddSubText);
        document.getElementById('removeSubTextBtn').addEventListener('click', onRemoveSubText);
        contextMenuSelectLinkBtn.addEventListener('click', onContextMenuSelectLink);
        contextMenuClearLinkBtn.addEventListener('click', onContextMenuClearLink);
        linkPickerSearchInput.addEventListener('input', renderLinkPickerTargets);

        nodeTextInput.addEventListener('blur', commitNodeUpdate);
        linkIdInput.addEventListener('blur', commitNodeUpdate);
        linkTextInput.addEventListener('blur', commitNodeUpdate);
        document.addEventListener('keydown', onKeydown);
        document.addEventListener('click', onDocumentClick);
        document.addEventListener('scroll', closeNodeMenu, true);

        initialize();

        async function initialize() {
            linkPickerModal = createLinkPickerModal();
            if (linkPickerModalEl) {
                linkPickerModalEl.addEventListener('shown.bs.modal', () => linkPickerSearchInput.focus());
                linkPickerModalEl.addEventListener('hidden.bs.modal', resetLinkPickerState);
            }
            await refreshState();
            renderAll();
        }

        async function refreshState() {
            try {
                const response = await fetch('@Url.Action("State", "ProtocolEditor")');
                if (!response.ok) {
                    setStatus('Unable to load protocol state.');
                    return;
                }

                state = await response.json();
                ensureSelection();
            } catch (error) {
                setStatus('Unable to reach server while loading protocol state.');
            }
        }

        function ensureSelection() {
            if (selectedNodeId == null) {
                selectedNodeId = state.document.sections.length ? state.document.sections[0].id : null;
                return;
            }

            if (!findNodeById(state.document.sections, selectedNodeId)) {
                selectedNodeId = state.document.sections.length ? state.document.sections[0].id : null;
            }
        }

        function renderAll() {
            ensureContextNodeExists();
            renderTree();
            renderDetails();
            updateToggleAllSectionsButton();
            setStatus(`Undo: ${state.undoCount} | Redo: ${state.redoCount}`);
        }

        function renderTree() {
            treeHost.innerHTML = '';
            reconcileCollapsedSections();

            const root = document.createElement('ul');
            root.className = 'protocol-tree-root';

            state.document.sections.forEach(section => {
                root.appendChild(buildNode(section, 0));
            });

            treeHost.appendChild(root);
            attachRootDropZone(root);
            scrollPendingNodeIntoView();
        }

        function buildNode(node, depth) {
            const nodeKind = normalizeKind(node.kind);
            const isSectionNode = nodeKind === 'section' && depth === 0;
            const isCollapsedSection = isSectionNode && collapsedSectionIds.has(node.id);
            const item = document.createElement('li');
            item.className = `protocol-tree-item ${isSectionNode ? 'protocol-tree-item-section' : ''} ${isCollapsedSection ? 'is-collapsed' : ''}`;

            const row = document.createElement('div');
            row.className = 'protocol-tree-row';

            const toggle = document.createElement('button');
            toggle.type = 'button';
            toggle.className = `protocol-tree-toggle ${isSectionNode ? '' : 'is-hidden'}`.trim();
            toggle.setAttribute('aria-label', isCollapsedSection ? 'Expand section' : 'Collapse section');
            toggle.textContent = isCollapsedSection ? '▸' : '▾';
            if (isSectionNode) {
                toggle.addEventListener('click', event => {
                    event.preventDefault();
                    event.stopPropagation();
                    toggleSectionCollapsed(node.id);
                    renderAll();
                });
            }
            row.appendChild(toggle);

            const button = document.createElement('button');
            button.type = 'button';
            button.className = `protocol-tree-node protocol-tree-node-${nodeKind || 'node'} ${selectedNodeId === node.id ? 'is-selected' : ''}`;
            button.style.paddingLeft = `${10 + depth * 14}px`;
            button.dataset.nodeId = String(node.id);
            button.title = 'Drag to reorder';

            const dragHandle = document.createElement('span');
            dragHandle.className = 'protocol-tree-drag-handle';
            dragHandle.textContent = '⋮⋮';

            const label = document.createElement('span');
            label.className = 'protocol-tree-node-label';
            label.textContent = node.text || '(empty)';

            button.appendChild(dragHandle);
            button.appendChild(label);
            button.draggable = true;
            button.addEventListener('click', () => {
                selectedNodeId = node.id;
                renderAll();
            });
            button.addEventListener('contextmenu', event => {
                event.preventDefault();
                openNodeMenu(node.id, event.clientX, event.clientY);
            });
            button.addEventListener('dragstart', event => onDragStart(event, node.id));
            button.addEventListener('dragover', onDragOver);
            button.addEventListener('dragenter', event => onDragEnter(event, button));
            button.addEventListener('dragleave', event => onDragLeave(event, button));
            button.addEventListener('drop', event => onDrop(event, node));
            button.addEventListener('dragend', () => {
                dragNodeId = null;
                clearDropIndicators();
            });
            row.appendChild(button);
            item.appendChild(row);

            if (node.children && node.children.length && !isCollapsedSection) {
                const childList = document.createElement('ul');
                childList.className = 'protocol-tree-children';
                node.children.forEach(child => childList.appendChild(buildNode(child, depth + 1)));
                item.appendChild(childList);
            }

            return item;
        }

        function queueScrollToNode(nodeId) {
            pendingScrollToNodeId = nodeId;
        }

        function scrollPendingNodeIntoView() {
            if (pendingScrollToNodeId == null || selectedNodeId !== pendingScrollToNodeId) {
                pendingScrollToNodeId = null;
                return;
            }

            const nodeButton = treeHost.querySelector(`.protocol-tree-node[data-node-id="${pendingScrollToNodeId}"]`);
            pendingScrollToNodeId = null;
            if (!nodeButton) {
                return;
            }

            scrollNodeIntoContainerView(nodeButton, treeHost);
        }

        function scrollNodeIntoContainerView(node, fallbackContainer) {
            const container = findScrollableAncestor(node, fallbackContainer);
            if (!container) {
                return;
            }

            const nodeRect = node.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();
            const padding = 8;

            if (nodeRect.top < containerRect.top) {
                container.scrollTop += nodeRect.top - containerRect.top - padding;
                return;
            }

            if (nodeRect.bottom > containerRect.bottom) {
                container.scrollTop += nodeRect.bottom - containerRect.bottom + padding;
            }
        }

        function findScrollableAncestor(element, fallback) {
            let current = element?.parentElement || null;
            while (current) {
                const style = window.getComputedStyle(current);
                const overflowY = style.overflowY;
                const canScrollY = (overflowY === 'auto' || overflowY === 'scroll' || overflowY === 'overlay')
                    && current.scrollHeight > current.clientHeight;
                if (canScrollY) {
                    return current;
                }

                current = current.parentElement;
            }

            return fallback || null;
        }

        function loadCollapsedIdSet(storageKey) {
            try {
                const raw = localStorage.getItem(storageKey);
                if (!raw) {
                    return new Set();
                }

                const parsed = JSON.parse(raw);
                if (!Array.isArray(parsed)) {
                    return new Set();
                }

                return new Set(
                    parsed
                        .map(item => Number(item))
                        .filter(item => Number.isFinite(item)));
            } catch {
                return new Set();
            }
        }

        function saveCollapsedIdSet(storageKey, ids) {
            try {
                localStorage.setItem(storageKey, JSON.stringify(Array.from(ids)));
            } catch {
                // Ignore storage failures; collapse behavior still works for current session.
            }
        }

        function reconcileCollapsedSections() {
            const validSectionIds = new Set(
                state.document.sections
                    .map(section => Number(section.id))
                    .filter(id => Number.isFinite(id)));

            const next = new Set();
            collapsedSectionIds.forEach(id => {
                if (validSectionIds.has(id)) {
                    next.add(id);
                }
            });

            if (next.size !== collapsedSectionIds.size) {
                collapsedSectionIds = next;
                saveCollapsedIdSet(collapseStorageKey, collapsedSectionIds);
            }
        }

        function toggleSectionCollapsed(sectionId) {
            if (collapsedSectionIds.has(sectionId)) {
                collapsedSectionIds.delete(sectionId);
                const section = findNodeById(state.document.sections, sectionId);
                const firstChild = section && section.children && section.children.length ? section.children[0] : null;
                if (firstChild) {
                    queueScrollToNode(firstChild.id);
                }
                saveCollapsedIdSet(collapseStorageKey, collapsedSectionIds);
                return;
            }

            collapsedSectionIds.add(sectionId);
            const section = findNodeById(state.document.sections, sectionId);
            if (section && isDescendantNode(section.children || [], selectedNodeId)) {
                selectedNodeId = sectionId;
            }
            saveCollapsedIdSet(collapseStorageKey, collapsedSectionIds);
        }

        function onToggleAllSections() {
            const sections = state.document.sections || [];
            if (!sections.length) {
                return;
            }

            if (areAllSectionsCollapsed(sections)) {
                collapsedSectionIds = new Set();
                saveCollapsedIdSet(collapseStorageKey, collapsedSectionIds);
                renderAll();
                return;
            }

            collapsedSectionIds = new Set(sections.map(section => section.id));
            const owningSectionId = findOwningSectionId(selectedNodeId);
            if (owningSectionId != null) {
                selectedNodeId = owningSectionId;
            }

            saveCollapsedIdSet(collapseStorageKey, collapsedSectionIds);
            renderAll();
        }

        function areAllSectionsCollapsed(sections) {
            if (!sections.length) {
                return false;
            }

            return sections.every(section => collapsedSectionIds.has(section.id));
        }

        function updateToggleAllSectionsButton() {
            if (!toggleAllSectionsBtn) {
                return;
            }

            const sections = state.document.sections || [];
            toggleAllSectionsBtn.disabled = sections.length === 0;
            toggleAllSectionsBtn.textContent = areAllSectionsCollapsed(sections)
                ? 'Expand Sections'
                : 'Collapse Sections';
        }

        function findOwningSectionId(nodeId) {
            if (!Number.isFinite(Number(nodeId))) {
                return null;
            }

            for (const section of state.document.sections || []) {
                if (section.id === nodeId || isDescendantNode(section.children || [], nodeId)) {
                    return section.id;
                }
            }

            return null;
        }

        function reconcileLinkPickerCollapsedSections() {
            const validSectionIds = new Set(
                state.document.sections
                    .map(section => Number(section.id))
                    .filter(id => Number.isFinite(id)));

            const next = new Set();
            collapsedLinkPickerSectionIds.forEach(id => {
                if (validSectionIds.has(id)) {
                    next.add(id);
                }
            });

            if (next.size !== collapsedLinkPickerSectionIds.size) {
                collapsedLinkPickerSectionIds = next;
                saveCollapsedIdSet(linkPickerCollapseStorageKey, collapsedLinkPickerSectionIds);
            }
        }

        function isDescendantNode(nodes, targetId) {
            if (!Number.isFinite(Number(targetId))) {
                return false;
            }

            for (const node of nodes || []) {
                if (node.id === targetId || isDescendantNode(node.children || [], targetId)) {
                    return true;
                }
            }

            return false;
        }

        function ensureContextNodeExists() {
            if (contextMenuNodeId != null && !findNodeById(state.document.sections, contextMenuNodeId)) {
                closeNodeMenu();
            }

            if (linkPickerSourceNodeId != null && !findNodeById(state.document.sections, linkPickerSourceNodeId)) {
                closeLinkPicker();
            }
        }

        function createLinkPickerModal() {
            if (!window.bootstrap || !window.bootstrap.Modal) {
                return null;
            }

            return new window.bootstrap.Modal(linkPickerModalEl);
        }

        function onDocumentClick(event) {
            if (nodeContextMenu.contains(event.target)) {
                return;
            }

            closeNodeMenu();
        }

        function openNodeMenu(nodeId, x, y) {
            contextMenuNodeId = nodeId;
            nodeContextMenu.style.left = `${x}px`;
            nodeContextMenu.style.top = `${y}px`;
            nodeContextMenu.style.display = 'block';
        }

        function closeNodeMenu() {
            contextMenuNodeId = null;
            nodeContextMenu.style.display = 'none';
        }

        async function onContextMenuSelectLink() {
            if (contextMenuNodeId == null) {
                return;
            }

            openLinkPicker(contextMenuNodeId);
            closeNodeMenu();
        }

        async function onContextMenuClearLink() {
            if (contextMenuNodeId == null) {
                return;
            }

            await clearNodeLink(contextMenuNodeId);
            closeNodeMenu();
        }

        function openLinkPicker(sourceNodeId) {
            linkPickerSourceNodeId = sourceNodeId;
            linkPickerSearchInput.value = '';
            renderLinkPickerSource();
            renderLinkPickerTargets();

            if (linkPickerModal) {
                linkPickerModal.show();
                return;
            }

            setStatus('Link picker modal is unavailable.');
            resetLinkPickerState();
        }

        function closeLinkPicker() {
            resetLinkPickerState();
            if (linkPickerModal) {
                linkPickerModal.hide();
            }
        }

        function resetLinkPickerState() {
            linkPickerSourceNodeId = null;
            linkPickerTree.innerHTML = '';
            linkPickerSourceLabel.textContent = '';
        }

        function renderLinkPickerSource() {
            const source = getLinkPickerSourceNode();
            if (!source) {
                linkPickerSourceLabel.textContent = 'Source node not found.';
                return;
            }

            linkPickerSourceLabel.textContent = `Source: #${source.id} ${source.text || '(empty)'}`;
        }

        function renderLinkPickerTargets() {
            linkPickerTree.innerHTML = '';
            const source = getLinkPickerSourceNode();
            if (!source) {
                return;
            }

            const filter = (linkPickerSearchInput.value || '').trim().toLowerCase();
            reconcileLinkPickerCollapsedSections();
            const sections = state.document.sections || [];
            const groups = sections
                .map(section => buildLinkPickerSectionGroup(section, source.id, filter))
                .filter(group => group != null);
            if (!groups.length) {
                linkPickerTree.textContent = 'No matching nodes available.';
                return;
            }

            const container = document.createElement('div');
            container.className = 'protocol-link-picker-sections';
            groups.forEach(group => container.appendChild(group));
            linkPickerTree.appendChild(container);
        }

        function getLinkPickerSourceNode() {
            if (linkPickerSourceNodeId == null) {
                return null;
            }

            return findNodeById(state.document.sections, linkPickerSourceNodeId);
        }

        function flattenNodes(nodes, depth = 0, output = []) {
            nodes.forEach(node => {
                output.push({ node, depth });
                flattenNodes(node.children || [], depth + 1, output);
            });
            return output;
        }

        function isCandidateTarget(sourceId, node, filter) {
            if (node.id === sourceId || isDescendantLink(sourceId, node.id)) {
                return false;
            }

            return matchesLinkFilter(node, filter);
        }

        function isDescendantLink(sourceId, targetId) {
            const source = findNodeById(state.document.sections, sourceId);
            if (!source) {
                return false;
            }

            return findNodeById(source.children || [], targetId) != null;
        }

        function matchesLinkFilter(node, filter) {
            if (!filter) {
                return true;
            }

            const text = (node.text || '').toLowerCase();
            return text.includes(filter) || String(node.id).includes(filter);
        }

        function buildLinkTargetButton(entry) {
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'list-group-item list-group-item-action protocol-link-picker-item';
            button.style.paddingLeft = `${10 + entry.depth * 14}px`;
            button.textContent = `#${entry.node.id} ${entry.node.text || '(empty)'}`;
            button.addEventListener('click', async () => {
                await selectLinkTarget(entry.node.id);
            });
            return button;
        }

        function buildLinkPickerSectionGroup(section, sourceId, filter) {
            const entries = flattenNodes([section])
                .filter(entry => isCandidateTarget(sourceId, entry.node, filter));
            if (!entries.length) {
                return null;
            }

            const canSelectSection = entries.some(entry => entry.node.id === section.id);
            const childEntries = entries.filter(entry => entry.node.id !== section.id);
            const isCollapsed = collapsedLinkPickerSectionIds.has(section.id);
            const group = document.createElement('div');
            group.className = 'list-group protocol-link-picker-list protocol-link-picker-section-group';
            group.appendChild(buildLinkPickerSectionHeader(section, canSelectSection, isCollapsed));
            if (!isCollapsed) {
                childEntries.forEach(entry => group.appendChild(buildLinkTargetButton(entry)));
            }

            return group;
        }

        function buildLinkPickerSectionHeader(section, canSelectSection, isCollapsed) {
            const header = document.createElement('div');
            header.className = 'list-group-item protocol-link-picker-item protocol-link-picker-section-header';

            const toggle = document.createElement('button');
            toggle.type = 'button';
            toggle.className = 'protocol-link-picker-section-toggle';
            toggle.setAttribute('aria-label', isCollapsed ? 'Expand section' : 'Collapse section');
            toggle.textContent = isCollapsed ? '▸' : '▾';
            toggle.addEventListener('click', event => {
                event.preventDefault();
                event.stopPropagation();
                toggleLinkPickerSectionCollapsed(section.id);
                renderLinkPickerTargets();
            });
            header.appendChild(toggle);

            if (canSelectSection) {
                const selectButton = document.createElement('button');
                selectButton.type = 'button';
                selectButton.className = 'protocol-link-picker-section-target';
                selectButton.textContent = `#${section.id} ${section.text || '(empty)'}`;
                selectButton.addEventListener('click', async () => {
                    await selectLinkTarget(section.id);
                });
                header.appendChild(selectButton);
                return header;
            }

            const label = document.createElement('span');
            label.className = 'protocol-link-picker-section-label';
            label.textContent = `#${section.id} ${section.text || '(empty)'}`;
            header.appendChild(label);
            return header;
        }

        function toggleLinkPickerSectionCollapsed(sectionId) {
            if (collapsedLinkPickerSectionIds.has(sectionId)) {
                collapsedLinkPickerSectionIds.delete(sectionId);
            } else {
                collapsedLinkPickerSectionIds.add(sectionId);
            }

            saveCollapsedIdSet(linkPickerCollapseStorageKey, collapsedLinkPickerSectionIds);
        }

        async function selectLinkTarget(targetNodeId) {
            const source = getLinkPickerSourceNode();
            if (!source) {
                return;
            }

            if (source.id === targetNodeId || isDescendantLink(source.id, targetNodeId)) {
                setStatus('Invalid link target selected.');
                return;
            }

            const target = findNodeById(state.document.sections, targetNodeId);
            if (!target) {
                setStatus('Target node not found.');
                return;
            }

            const updated = await updateNodeLink(source.id, target.id, target.text || '');
            if (!updated) {
                return;
            }

            closeLinkPicker();
            setStatus(`Linked #${source.id} to #${target.id}.`);
        }

        async function clearNodeLink(sourceNodeId) {
            const updated = await updateNodeLink(sourceNodeId, -1, '');
            if (!updated) {
                return;
            }

            setStatus(`Cleared link for #${sourceNodeId}.`);
        }

        async function updateNodeLink(sourceNodeId, linkId, linkText) {
            const source = findNodeById(state.document.sections, sourceNodeId);
            if (!source) {
                setStatus('Source node not found.');
                return false;
            }

            selectedNodeId = source.id;
            return await postState('UpdateNode', {
                nodeId: source.id,
                text: source.text || '',
                linkId,
                linkText: linkText || ''
            });
        }

        function renderDetails() {
            const selected = getSelectedNode();

            if (!selected) {
                statementIdInput.value = '';
                nodeTextInput.value = '';
                linkIdInput.value = '';
                linkTextInput.value = '';
                subTextList.innerHTML = '';
                setInputsEnabled(false);
                return;
            }

            setInputsEnabled(true);
            statementIdInput.value = selected.id;
            nodeTextInput.value = selected.text || '';
            linkIdInput.value = selected.linkId ?? -1;
            linkTextInput.value = selected.linkText || '';
            renderSubText(selected.subText || []);
        }

        function renderSubText(items) {
            subTextList.innerHTML = '';
            items.forEach(value => {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = value;
                subTextList.appendChild(option);
            });
        }

        function setInputsEnabled(enabled) {
            nodeTextInput.disabled = !enabled;
            linkIdInput.disabled = !enabled;
            linkTextInput.disabled = !enabled;
            subTextInput.disabled = !enabled;
            subTextList.disabled = !enabled;
            document.getElementById('addChildBtn').disabled = !enabled;
            document.getElementById('removeNodeBtn').disabled = !enabled;
            document.getElementById('addSubTextBtn').disabled = !enabled;
            document.getElementById('removeSubTextBtn').disabled = !enabled;
        }

        function getSelectedNode() {
            if (selectedNodeId == null) {
                return null;
            }

            return findNodeById(state.document.sections, selectedNodeId);
        }

        function findNodeById(nodes, id) {
            for (const node of nodes) {
                if (node.id === id) {
                    return node;
                }

                const childFound = findNodeById(node.children || [], id);
                if (childFound) {
                    return childFound;
                }
            }

            return null;
        }

        function findParentId(nodes, targetId, parentId) {
            for (const node of nodes) {
                if (node.id === targetId) {
                    return parentId;
                }

                const childParentId = findParentId(node.children || [], targetId, node.id);
                if (childParentId != null) {
                    return childParentId;
                }
            }

            return null;
        }

        function findIndexInParent(parentId, nodeId) {
            if (parentId === 0) {
                return state.document.sections.findIndex(node => node.id === nodeId);
            }

            const parent = findNodeById(state.document.sections, parentId);
            if (!parent) {
                return -1;
            }

            return (parent.children || []).findIndex(node => node.id === nodeId);
        }

        function onDragStart(event, nodeId) {
            dragNodeId = nodeId;
            const source = treeHost.querySelector(`.protocol-tree-node[data-node-id="${nodeId}"]`);
            if (source) {
                source.classList.add('is-dragging');
            }
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', String(nodeId));
        }

        function onDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
        }

        function onDragEnter(event, element) {
            event.preventDefault();
            element.classList.add('is-drop-target');
        }

        function onDragLeave(event, element) {
            if (event.currentTarget.contains(event.relatedTarget)) {
                return;
            }

            element.classList.remove('is-drop-target');
        }

        async function onDrop(event, targetNode) {
            event.preventDefault();
            clearDropIndicators();

            const draggedId = Number(event.dataTransfer.getData('text/plain') || dragNodeId);
            if (!Number.isFinite(draggedId) || draggedId === targetNode.id) {
                return;
            }

            const dragged = findNodeById(state.document.sections, draggedId);
            if (!dragged) {
                return;
            }

            const moveRequest = buildMoveRequest(dragged, targetNode);
            if (!moveRequest) {
                setStatus('Invalid drop target.');
                return;
            }

            await postState('MoveNode', moveRequest);
            selectedNodeId = draggedId;
            renderAll();
        }

        function buildMoveRequest(dragged, target) {
            const draggedKind = normalizeKind(dragged.kind);
            const targetKind = normalizeKind(target.kind);

            if (draggedKind === 'section') {
                if (targetKind !== 'section') {
                    return null;
                }

                const targetIndex = findIndexInParent(0, target.id);
                if (targetIndex < 0) {
                    return null;
                }

                return {
                    nodeId: dragged.id,
                    parentId: 0,
                    targetIndex
                };
            }

            if (targetKind === 'section') {
                return {
                    nodeId: dragged.id,
                    parentId: target.id,
                    targetIndex: (target.children || []).length
                };
            }

            const targetParentId = findParentId(state.document.sections, target.id, 0);
            if (targetParentId == null) {
                return null;
            }

            const targetIndex = findIndexInParent(targetParentId, target.id);
            if (targetIndex < 0) {
                return null;
            }

            return {
                nodeId: dragged.id,
                parentId: targetParentId,
                targetIndex
            };
        }

        function normalizeKind(kind) {
            if (typeof kind === 'string') {
                return kind.toLowerCase();
            }

            if (typeof kind === 'number') {
                if (kind === 1) {
                    return 'section';
                }

                if (kind === 2) {
                    return 'subsection';
                }

                return 'root';
            }

            return '';
        }

        function attachRootDropZone(rootElement) {
            rootElement.addEventListener('dragover', onDragOver);
            rootElement.addEventListener('drop', async event => {
                event.preventDefault();
                clearDropIndicators();

                const draggedId = Number(event.dataTransfer.getData('text/plain') || dragNodeId);
                if (!Number.isFinite(draggedId)) {
                    return;
                }

                const dragged = findNodeById(state.document.sections, draggedId);
                if (!dragged || normalizeKind(dragged.kind) !== 'section') {
                    return;
                }

                await postState('MoveNode', {
                    nodeId: draggedId,
                    parentId: 0,
                    targetIndex: state.document.sections.length
                });
                selectedNodeId = draggedId;
                renderAll();
            });
        }

        function clearDropIndicators() {
            treeHost.querySelectorAll('.is-drop-target, .is-dragging').forEach(element => {
                element.classList.remove('is-drop-target', 'is-dragging');
            });
        }

        async function commitNodeUpdate() {
            if (selectedNodeId == null) {
                return;
            }

            await postState('UpdateNode', {
                nodeId: selectedNodeId,
                text: nodeTextInput.value || '',
                linkId: Number.isFinite(Number(linkIdInput.value)) ? Number(linkIdInput.value) : -1,
                linkText: linkTextInput.value || ''
            });
        }

        async function onAddSection() {
            const text = prompt('Section name:', 'New Section');
            if (text == null) {
                return;
            }

            const sectionsBeforeAdd = state.document.sections || [];
            const sectionIdsBeforeAdd = new Set(sectionsBeforeAdd.map(section => section.id));
            const success = await postState('AddSection', { text }, { skipRender: true });
            if (!success) {
                return;
            }

            const sectionsAfterAdd = state.document.sections || [];
            const addedSection = sectionsAfterAdd.find(section => !sectionIdsBeforeAdd.has(section.id));
            const sectionToSelect = addedSection || sectionsAfterAdd[sectionsAfterAdd.length - 1];
            if (sectionToSelect) {
                selectedNodeId = sectionToSelect.id;
                queueScrollToNode(sectionToSelect.id);
            }

            renderAll();
        }

        async function onAddChild() {
            if (selectedNodeId == null) {
                return;
            }

            const text = prompt('Child statement:', 'New Node');
            if (text == null) {
                return;
            }

            await postState('AddChild', {
                parentId: selectedNodeId,
                text
            });
            renderAll();
        }

        async function onRemoveNode() {
            if (selectedNodeId == null) {
                return;
            }

            if (!confirm('Remove selected node?')) {
                return;
            }

            await postState('RemoveNode', {
                nodeId: selectedNodeId
            });
            ensureSelection();
            renderAll();
        }

        async function onAddSubText() {
            if (selectedNodeId == null) {
                return;
            }

            const value = (subTextInput.value || '').trim();
            if (!value) {
                return;
            }

            await postState('AddSubText', {
                nodeId: selectedNodeId,
                value
            });
            subTextInput.value = '';
            renderAll();
        }

        async function onRemoveSubText() {
            if (selectedNodeId == null || !subTextList.value) {
                return;
            }

            await postState('RemoveSubText', {
                nodeId: selectedNodeId,
                value: subTextList.value
            });
            renderAll();
        }

        async function onReset() {
            if (!confirm('Reset protocol to starter content?')) {
                return;
            }

            await postState('Reset', {});
            ensureSelection();
            renderAll();
        }

        function onExportXml() {
            window.open('@Url.Action("ExportXml", "ProtocolEditor")', '_blank');
        }

        function onImportXml() {
            importXmlFileInput.click();
        }

        async function onImportXmlSelected() {
            const file = importXmlFileInput.files && importXmlFileInput.files[0];
            if (!file) {
                return;
            }

            const payload = new FormData();
            payload.append('file', file);

            try {
                const response = await fetch('/ProtocolEditor/ImportXmlUpload', {
                    method: 'POST',
                    headers: {
                        'RequestVerificationToken': token
                    },
                    body: payload
                });

                if (!response.ok) {
                    const errorPayload = await response.json().catch(() => null);
                    setStatus(errorPayload?.error || 'Request failed: Import Protocol');
                    return;
                }

                const next = await response.json();
                state = next;
                ensureSelection();
                renderAll();
                setStatus(`Imported protocol and saved to ${next.savedPath || 'server storage'}`);
            } catch (error) {
                setStatus('Unable to reach server while importing protocol.');
            } finally {
                importXmlFileInput.value = '';
            }
        }

        async function onSaveXml() {
            try {
                const response = await fetch('/ProtocolEditor/SaveXml', {
                    method: 'POST',
                    headers: {
                        'RequestVerificationToken': token
                    }
                });

                if (!response.ok) {
                    const payload = await response.json().catch(() => null);
                    setStatus(payload?.error || 'Request failed: Save Protocol');
                    return;
                }

                const payload = await response.json();
                state = payload;
                ensureSelection();
                renderAll();
                setStatus(`Saved protocol to ${payload.savedPath || 'configured path'}`);
            } catch (error) {
                setStatus('Unable to reach server while saving protocol.');
            }
        }

        async function onSetDefaultProtocol() {
            try {
                const response = await fetch('/ProtocolEditor/SetDefaultProtocol', {
                    method: 'POST',
                    headers: {
                        'RequestVerificationToken': token
                    }
                });

                if (!response.ok) {
                    const payload = await response.json().catch(() => null);
                    setStatus(payload?.error || 'Request failed: SetDefaultProtocol');
                    return;
                }

                const payload = await response.json();
                state = payload;
                ensureSelection();
                renderAll();
                setStatus(`Set default protocol at ${payload.defaultPath || 'configured path'}`);
            } catch (error) {
                setStatus('Unable to reach server while setting default protocol.');
            }
        }

        async function onKeydown(event) {
            if (event.key === 'Escape') {
                closeNodeMenu();
                if (linkPickerModal) {
                    linkPickerModal.hide();
                }
                return;
            }

            if (!event.ctrlKey) {
                return;
            }

            if (event.key.toLowerCase() === 'z') {
                event.preventDefault();
                await postState('Undo', {});
                return;
            }

            if (event.key.toLowerCase() === 'y') {
                event.preventDefault();
                await postState('Redo', {});
            }
        }

        async function postState(action, payload, options) {
            const settings = options || {};
            try {
                const response = await fetch(`/ProtocolEditor/${action}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': token
                    },
                    body: JSON.stringify(payload || {})
                });

                if (!response.ok) {
                    const payload = await response.json().catch(() => null);
                    setStatus(payload?.error || `Request failed: ${action}`);
                    return false;
                }

                state = await response.json();
                ensureSelection();
                if (!settings.skipRender) {
                    renderAll();
                }
                return true;
            } catch (error) {
                setStatus(`Unable to reach server while processing ${action}.`);
                return false;
            }
        }

        function setStatus(message) {
            statusEl.textContent = message;
        }
    })();
</script>
}
